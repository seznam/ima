"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[8117],{7466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"cli/additional-features","title":"Additional features","description":"CLI > Advanced CLI techniques and other features","source":"@site/../docs/cli/additional-features.md","sourceDirName":"cli","slug":"/cli/additional-features","permalink":"/cli/additional-features","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/cli/additional-features.md","tags":[],"version":"current","lastUpdatedBy":"Miroslav Jancarik","lastUpdatedAt":1738921043000,"frontMatter":{"title":"Additional features","description":"CLI > Advanced CLI techniques and other features"},"sidebar":"docs","previous":{"title":"ima.config.js","permalink":"/cli/ima-config-js"},"next":{"title":"CLI Plugins API","permalink":"/cli/cli-plugins-api"}}');var s=t(2540),r=t(3023);const o={title:"Additional features",description:"CLI > Advanced CLI techniques and other features"},l=void 0,a={},c=[{value:"Polyfills",id:"polyfills",level:2},{value:"Static files in <code>public</code> folder",id:"static-files-in-public-folder",level:3},{value:"Importing polyfills at top of the <code>main.js</code> file",id:"importing-polyfills-at-top-of-the-mainjs-file",level:3},{value:"Optional <code>polyfill.js</code> and <code>polyfill.es.js</code> entry points",id:"optional-polyfilljs-and-polyfillesjs-entry-points",level:3},{value:"IMA.js Runtime",id:"imajs-runtime",level:2},{value:"<code>runner.ejs</code>",id:"runnerejs",level:3},{value:"Extending default script",id:"extending-default-script",level:4},{value:"GenerateRuntimePlugin",id:"generateruntimeplugin",level:3},{value:"Dev server",id:"dev-server",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This section describes multiple additional features that are either directly provided by the CLI or indirectly with the help of additional development packages ",(0,s.jsx)(n.code,{children:"@ima/hmr-client"}),", ",(0,s.jsx)(n.code,{children:"@ima/error-overlay"}),", ",(0,s.jsx)(n.code,{children:"@ima/dev-utils"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"polyfills",children:"Polyfills"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you may need to include additional custom polyfills to fully support your application in multiple environments. There are multiple ways to achieve this."}),"\n",(0,s.jsxs)(n.h3,{id:"static-files-in-public-folder",children:["Static files in ",(0,s.jsx)(n.code,{children:"public"})," folder"]}),"\n",(0,s.jsxs)(n.p,{children:["The easies way, is to put your polyfill files directly into the ",(0,s.jsx)(n.a,{href:"/cli/compiler-features#apppublic-folder",children:"app/public"})," folder and load them either by extending the ",(0,s.jsx)(n.code,{children:"$Source"})," configuration in the ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/create-ima-app/template/server/config/environment.js#L29",children:"app environment"})," or customizing the application's ",(0,s.jsx)(n.code,{children:"DocumentView.jsx"})," and ",(0,s.jsx)(n.code,{children:"spa.html"})," templates with custom script tags:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"title=./app/document/DocumentView.jsx",children:"{/* ... */}\n<body>\n  <script src='/static/public/custom-polyfill.js' />\n  <div\n    id={this.constructor.masterElementId}\n    dangerouslySetInnerHTML={{ __html: this.props.page }}\n  />\n  <script\n    id='revivalSettings'\n    dangerouslySetInnerHTML={{ __html: this.props.revivalSettings }}\n  />\n</body>\n{/* ... */}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"importing-polyfills-at-top-of-the-mainjs-file",children:["Importing polyfills at top of the ",(0,s.jsx)(n.code,{children:"main.js"})," file"]}),"\n",(0,s.jsxs)(n.p,{children:["Additionally you can import (or put) polyfills at the top of the ",(0,s.jsx)(n.code,{children:"./app/main.js"})," entry point."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./app/main.js",children:"import 'abortcontroller-polyfill/dist/polyfill-patch-fetch';\n\nimport './less/app.less';\n\nimport * as ima from '@ima/core';\nimport initBindApp from 'app/config/bind';\n//...\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"optional-polyfilljs-and-polyfillesjs-entry-points",children:["Optional ",(0,s.jsx)(n.code,{children:"polyfill.js"})," and ",(0,s.jsx)(n.code,{children:"polyfill.es.js"})," entry points"]}),"\n",(0,s.jsxs)(n.p,{children:["Lastly there are special ",(0,s.jsx)(n.code,{children:"polyfill.js"})," and ",(0,s.jsx)(n.code,{children:"polyfill.es.js"})," files that you can create in the root of the ",(0,s.jsx)(n.code,{children:"app"})," directory. These, when bundled through webpack are available as separate JS files and are not part of the final ",(0,s.jsx)(n.code,{children:"app.bundle.js"})," file."]}),"\n",(0,s.jsxs)(n.p,{children:["As with the previous option, you can either import the polyfills from the ",(0,s.jsx)(n.code,{children:"node_modules"})," packages, or use their source code directly, by copying it into this file."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Both files are ",(0,s.jsx)(n.strong,{children:"optional"}),", this means that you can use, either one of those or don't use them at all. Similarly to the first option, don't forget to add the newly generated polyfill.js files somewhere in the source, so they are loaded on app startup."]})}),"\n",(0,s.jsx)(n.h2,{id:"imajs-runtime",children:"IMA.js Runtime"}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.a,{href:"/cli/compiler-features#server-and-client-bundles",children:"Compiler features"})," section, we mentioned that the CLI is compiling 3 separate bundles, mainly two distinct client bundles, where each targets certain ",(0,s.jsx)(n.code,{children:"ECMAScript"})," version. This approach has 2 main advantages:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["We're still able to support pretty much ",(0,s.jsx)(n.strong,{children:"every currently supported browser version"})," (in case of the ",(0,s.jsx)(n.code,{children:"es2018"})," version)."]}),"\n",(0,s.jsxs)(n.li,{children:["We're also serving the latest native version to the modern browsers that support's it (",(0,s.jsx)(n.code,{children:"es2022"})," version). This ",(0,s.jsx)(n.strong,{children:"bundle is also much smaller"})," since it contains very low amount of ",(0,s.jsx)(n.code,{children:"core-js"})," polyfills and should have ",(0,s.jsx)(n.strong,{children:"better performance"}),", because native implementations of existing APIs are usually faster than provided polyfills."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can customize source files for both versions in the ",(0,s.jsx)(n.code,{children:"$Source"})," option of the ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/create-ima-app/template/server/config/environment.js#L29",children:"app environment"})," configuration file. This sources definition is then used by the IMA.js Runner, which then ",(0,s.jsx)(n.strong,{children:"chooses"})," (",(0,s.jsx)(n.em,{children:"on the client side before app init"}),") ",(0,s.jsx)(n.strong,{children:"the most suitable version"})," for the current browser environment and ",(0,s.jsx)(n.strong,{children:"injects associated scripts into the DOM"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This is done by executing few small scripts, where each script target's certain ECMAScript feature. Based on these results, the runner injects the best version of client bundle suitable for that concrete browser environment. It also makes sure to wait until all scripts have loaded before executing the webpack runtime."}),"\n",(0,s.jsxs)(n.p,{children:["This makes sure that all external scripts that the app depends on (",(0,s.jsx)(n.em,{children:"languages"}),") are loaded correctly before it's execution and allows them to be loaded ",(0,s.jsx)(n.code,{children:"async"})," to ",(0,s.jsx)(n.strong,{children:"improve page load times"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"runnerejs",children:(0,s.jsx)(n.code,{children:"runner.ejs"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/core/polyfill/runner.ejs",children:"IMA.js runner"})," is simple snippet of JS code, that is injected into the page automatically within the app ",(0,s.jsx)(n.code,{children:"revivalSettings"}),". It can be completely customizable by defining the runner overrides on the client window before it is injected into the DOM. It will then merge any existing overrides to the original runner before it's execution."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The runner script is intentionally written in es5 compatible syntax to make sure, that it can be executed on any environment and report using ",(0,s.jsx)(n.code,{children:"onUnsupported"})," callback, when current browser can't even interpret the ",(0,s.jsx)(n.code,{children:"es2018"})," version of the bundle. In this case the application then runs in ",(0,s.jsx)(n.strong,{children:"MPA"})," mode"]})}),"\n",(0,s.jsx)(n.h4,{id:"extending-default-script",children:"Extending default script"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned before the runner script is fully extensible. For example to implement custom ",(0,s.jsx)(n.code,{children:"onUnsupported()"})," and ",(0,s.jsx)(n.code,{children:"onError()"})," callbacks, you'd do something like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"title=./app/document/DocumentView.jsx",children:"<body>\n  {/* ... */}\n  <script>\n    window.$IMA = window.$IMA || {};\n    window.$IMA.$Runner = {\n      /**\n       * Optional onError handler. It is triggered in case the runtime\n       * code fails to run the application.\n       */\n      onError: function (error) {\n        throw new Error(error);\n      },\n\n      /**\n       * Optional onUnsupported handler. It is triggered in case tests\n       * for es and legacy version fails, which means that the APP runtime\n       * code is never executed.\n       */\n      onUnsupported: function() {\n        // Hit analytics with unsupported browser info\n      },\n    }\n  <\/script>\n  <script\n    id='revivalSettings'\n    dangerouslySetInnerHTML={{ __html: this.props.revivalSettings }}\n  />\n</body>\n{/* ... */}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Don't forget to apply the same changes to the ",(0,s.jsx)(n.code,{children:"spa.html"})]}),", otherwise only SSR rendered pages will contain this override."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Since you will usually never want to change anything on the IMA.js Runner (apart from the previously mentioned callbacks), we won't go much deeper into it's the ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/core/polyfill/runner.ejs",children:"source code"}),". You can always ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/core/polyfill/runner.ejs",children:"check it here"})," and use it as a reference for custom overrides."]}),(0,s.jsxs)(n.p,{children:["However simply keeping your ",(0,s.jsx)(n.code,{children:"@ima/*"})," dependencies up to will make sure, that you always receive the latest version of the runner script, which may evolve overtime."]})]}),"\n",(0,s.jsx)(n.h3,{id:"generateruntimeplugin",children:"GenerateRuntimePlugin"}),"\n",(0,s.jsxs)(n.p,{children:["Since the ",(0,s.jsx)(n.code,{children:"webpack"})," runtime is unique for every built, usually quite small, have to be loaded synchronously (",(0,s.jsx)(n.em,{children:"which can impact the page load performance"}),") and you would need to manually handle loading it's source code to the DOM, we have created ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/cli/src/webpack/plugins/GenerateRunnerPlugin/index.ts",children:"GenerateRuntimePlugin"})," to solve these issues."]}),"\n",(0,s.jsxs)(n.p,{children:["This plugin takes care of automatically generating the runtime consisting of the IMA.js runner code and webpack runtime (for both client bundles), which is then ",(0,s.jsx)(n.strong,{children:"injected directly into the SPA template or SSR rendered html page"}),". This means that you really don't have to worry about the existence of IMA.js runtime (while it's good to know that it does exist), since the framework handles all the hard work for you."]}),"\n",(0,s.jsx)(n.p,{children:"It also comes with some performance benefits, since inlining these small scripts directly into the HTML removes the need to load additional 2 scripts synchronously, after browser parses the initial DOM."}),"\n",(0,s.jsx)(n.h2,{id:"dev-server",children:"Dev server"}),"\n",(0,s.jsxs)(n.p,{children:["When you run your app using ",(0,s.jsx)(n.code,{children:"npx ima dev"})," command, apart from building your application in development mode with HMR and all other dev features enabled, the CLI also starts companion express server - the dev server."]}),"\n",(0,s.jsxs)(n.p,{children:["By default it runs on ",(0,s.jsx)(n.code,{children:"http://localhost:3101"})," (this can be customized through ",(0,s.jsx)(n.a,{href:"/cli/ima-config-js#devserver",children:"ima.config.js"})," or ",(0,s.jsx)(n.a,{href:"/cli/#dev-server-options",children:"CLI options"}),") and defines middlewares that are used mainly by the ",(0,s.jsx)(n.code,{children:"@ima/error-overlay"})," (to properly display parsed error code snippets). Additionally it uses ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-hot-middleware",children:"webpack-hot-middleware"})," and ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-dev-middleware",children:"webpack-dev-middleware"})," to ",(0,s.jsx)(n.strong,{children:"enable support for HMR"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t(3509).A+"",width:"2002",height:"1582"})}),"\n",(0,s.jsx)(n.p,{children:"Using separate small server to host these middleware doesn't force us to define them directly on the app server, which could essentially produce some errors in certain situations."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Usually you don't have to think about the dev server during development and can simply pretend that it doesn't exist, since it is handled entirely by the CLI scripts. You can always have a ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/cli/src/dev-server/devServer.ts",children:"look at the source code"})," to learn more."]}),(0,s.jsx)(n.admonition,{type:"note"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3509:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/cli-error-overlay-421cb5292785f513c7c5e4c4de5cd999.jpg"},3023:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(3696);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);