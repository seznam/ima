"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[7645],{2595:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"cli/cli-plugins-api","title":"CLI Plugins API","description":"CLI > CLI Plugins and their API","source":"@site/../docs/cli/cli-plugins-api.md","sourceDirName":"cli","slug":"/cli/cli-plugins-api","permalink":"/cli/cli-plugins-api","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/cli/cli-plugins-api.md","tags":[],"version":"current","lastUpdatedBy":"Jan \u0160ime\u010dek","lastUpdatedAt":1761308686000,"frontMatter":{"title":"CLI Plugins API","description":"CLI > CLI Plugins and their API"},"sidebar":"docs","previous":{"title":"Additional features","permalink":"/cli/additional-features"},"next":{"title":"Analyze Plugin","permalink":"/cli/plugins/analyze-plugin"}}');var s=i(2540),a=i(3023),l=i(3776),r=i(6052);const o={title:"CLI Plugins API",description:"CLI > CLI Plugins and their API"},c=void 0,u={},d=[{value:"CLI Plugins API",id:"cli-plugins-api",level:2},{value:"Creating a CLI plugin",id:"creating-a-cli-plugin",level:2},{value:"Extending the webpack config",id:"extending-the-webpack-config",level:3},{value:"Custom CLI arguments",id:"custom-cli-arguments",level:3},{value:"Accessing CLI arguments",id:"accessing-cli-arguments",level:3},{value:"Final results",id:"final-results",level:3},{value:"Using TypeScript",id:"using-typescript",level:3},{value:"Existing CLI plugins",id:"existing-cli-plugins",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The CLI comes with built-in support for plugins. Plugins are used to ",(0,s.jsx)(n.strong,{children:"extend"})," or ",(0,s.jsx)(n.strong,{children:"modify"})," existing webpack config very easily or even run some pre/post processing scripts during the build process."]}),"\n",(0,s.jsxs)(n.p,{children:["The CLI plugin is usually a class or an object implementing ",(0,s.jsx)(n.code,{children:"ImaCliPlugin"})," interface. This instance is then added to the ",(0,s.jsx)(n.a,{href:"/cli/ima-config-js#plugins",children:"plugins"})," array field in the ",(0,s.jsx)(n.code,{children:"ima.config.js"}),", which registers the plugin to the build process. Additionally to extending the webpack config, you have ability to provide additional custom CLI arguments."]}),"\n",(0,s.jsx)(n.h2,{id:"cli-plugins-api",children:"CLI Plugins API"}),"\n",(0,s.jsxs)(n.p,{children:["Each plugin has to comply with the ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/next/packages/cli/src/types.ts#L56",children:"following interface"}),". Even though almost v everything method is not required and marked as optional, your plugin should implement at least one of the following methods in order to be of any use. Otherwise it would still work but the plugin would not do anything."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"/**\n * Interface for ima/cli plugins that can be defined in plugins field in ima.conf.js. These can be used\n * to extend functionality of default CLI with custom cli arguments and webpack config overrides.\n */\nexport interface ImaCliPlugin {\n  /**\n   * Plugin name, used mainly for better debugging messages.\n   */\n  readonly name: string;\n\n  /**\n   * Optional additional CLI arguments to extend the set of existing ones.\n   */\n  readonly cliArgs?: Partial<Record<ImaCliCommand, CommandBuilder>>;\n\n  /**\n   * Optional plugin hook to do some pre processing right after the cli args are processed\n   * and the imaConfig is loaded, before the webpack config creation and compiler run.\n   */\n  preProcess?(args: ImaCliArgs, imaConfig: ImaConfig): Promise<void>;\n\n  /**\n   * Called right before creating webpack configurations after preProcess call.\n   * This hook lets you customize configuration contexts for each webpack config\n   * that will be generated. This is usefull when you need to overrite configuration\n   * contexts for values that are not editable anywhere else (like output folders).\n   */\n  prepareConfigurations?(\n    configurations: ImaConfigurationContext[],\n    imaConfig: ImaConfig,\n    args: ImaCliArgs\n  ): Promise<ImaConfigurationContext[]>;\n\n  /**\n   * Webpack callback function used by plugins to customize/extend ima webpack config before it's run.\n   */\n  webpack?(\n    config: Configuration,\n    ctx: ImaConfigurationContext,\n    imaConfig: ImaConfig\n  ): Promise<Configuration>;\n\n  /**\n   * Optional plugin hook to do some custom processing after the compilation has finished.\n   * Attention! This hook runs only for build command.\n   */\n  postProcess?(args: ImaCliArgs, imaConfig: ImaConfig): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-cli-plugin",children:"Creating a CLI plugin"}),"\n",(0,s.jsxs)(n.p,{children:["In this section we're going to create custom plugin, which generates assets manifest json file. To achieve this we'll use ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/webpack-manifest-plugin/",children:"WebpackManifestPlugin"})," and extend our webpack config. We'll also define some additional CLI arguments that will enable us to overwrite certain settings on demand."]}),"\n",(0,s.jsxs)(n.p,{children:["First we're going to install the ",(0,s.jsx)(n.code,{children:"webpack-manifest-plugin"}),":"]}),"\n",(0,s.jsxs)(l.A,{groupId:"npm2yarn",children:[(0,s.jsx)(r.A,{value:"npm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install webpack-manifest-plugin -D\n"})})}),(0,s.jsx)(r.A,{value:"yarn",label:"Yarn",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yarn add webpack-manifest-plugin --dev\n"})})}),(0,s.jsx)(r.A,{value:"pnpm",label:"pnpm",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm add webpack-manifest-plugin -D\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Then we need to define base class for our new CLI plugin. To make things easier we're going to work directly in the ",(0,s.jsx)(n.code,{children:"ima.config.js"})," but in reality you'd be better of creating separate npm package for easier sharing between multiple IMA.js projects."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"class CliManifestPlugin {\n  name = 'CliManifestPlugin';\n\n  webpack(config, ctx, imaConfig) {}\n}\n\nmodule.exports = {\n  plugins: [new CliManifestPlugin()],\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"extending-the-webpack-config",children:"Extending the webpack config"}),"\n",(0,s.jsxs)(n.p,{children:["Now we're going to initialize our manifest plugin. But we only want to do this when we are building the final bundle using the ",(0,s.jsx)(n.code,{children:"build"})," command. For that we can use the ",(0,s.jsx)(n.code,{children:"ctx: ImaContext"})," variable, which contains multiple flags and values describing current build context. One of those values is ",(0,s.jsx)(n.code,{children:"ctx.command"})," which can be either ",(0,s.jsx)(n.code,{children:"dev"})," or ",(0,s.jsx)(n.code,{children:"build"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"We are also going to make sure that we can provide options to our CLI plugin that are in this case passed directly to the webpack plugin."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"const { WebpackManifestPlugin } = require('webpack-manifest-plugin');\n\nclass CliManifestPlugin {\n  //...\n  #options = {};\n\n  constructor(options) {\n    this.#options = options;\n  }\n\n  webpack(config, ctx, imaConfig) {\n    if (ctx.command === 'build') {\n      config.plugins.push(new WebpackManifestPlugin(this.#options));\n    }\n\n    return config;\n  }\n  //...\n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Feel free to print the ",(0,s.jsx)(n.code,{children:"ctx"})," object into the console and examine it's properties."]}),(0,s.jsxs)(n.p,{children:["Similarly to the ",(0,s.jsx)(n.code,{children:"ctx"})," you can also use the ",(0,s.jsx)(n.code,{children:"imaConfig"})," parameter, which contains loaded ",(0,s.jsx)(n.code,{children:"ima.config.js"})," file. You can use this feature to have some additional custom plugin-specific definitions in the ",(0,s.jsx)(n.code,{children:"ima.config.js"})," file too, or use existing settings for some additional functionality."]})]}),"\n",(0,s.jsxs)(n.p,{children:["We're now going to use these options and pass ",(0,s.jsx)(n.a,{href:"https://github.com/shellscape/webpack-manifest-plugin#seed",children:"seed"})," argument to the plugin. The ",(0,s.jsx)(n.code,{children:"seed"})," object is used to share data between multiple manifest plugin instances (in our case multiple webpack compilations). This makes sure that the final ",(0,s.jsx)(n.code,{children:"manifest.json"})," file contains paths to all generated assets and is not overwritten by each finished webpack compilation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"//...\n// highlight-next-line\nconst manifestSeed = {};\n\nmodule.exports = {\n  // highlight-next-line\n  plugins: [new CliManifestPlugin({ seed: manifestSeed })],\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-cli-arguments",children:"Custom CLI arguments"}),"\n",(0,s.jsxs)(n.p,{children:["There may be times you'd like to customize or enable/disable certain features on demand using CLI arguments. To demonstrate this we're going to define ",(0,s.jsx)(n.code,{children:"manifestBasePath"})," CIL argument which will overwrite the ",(0,s.jsx)(n.a,{href:"https://github.com/shellscape/webpack-manifest-plugin#basepath",children:"basePath"})," plugin option."]}),"\n",(0,s.jsxs)(n.p,{children:["You can define CLI arguments for each command separately, in our case, since the plugin does something only in ",(0,s.jsx)(n.code,{children:"build"})," command, we're gonna do the same for the CLI arguments:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"class CliManifestPlugin {\n  //...\n  cliArgs = {\n    dev: undefined, // Dev args will go here\n    build: {\n      manifestBasePath: {\n        desc: 'Overwrite basePath default value',\n        type: 'string',\n      },\n    },\n  };\n  //...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The argument definition is passed directly to the ",(0,s.jsx)(n.code,{children:"yargs"})," parser, so anything that ",(0,s.jsx)(n.a,{href:"https://yargs.js.org/docs/#api-reference-optionskey-opt",children:"yargs options"})," accept can be passed here. If you've done everything correctly you should even see the new argument in the command ",(0,s.jsx)(n.code,{children:"--help"})," option:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-console",children:"npx ima build --help\n\nima build\n\nBuild an application for production\n\nOptions:\n// highlight-next-line\n  --manifestBasePath  Overwrite basePath default value  [string]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"accessing-cli-arguments",children:"Accessing CLI arguments"}),"\n",(0,s.jsxs)(n.p,{children:["CLI argument ",(0,s.jsxs)(n.strong,{children:["values are merged into the ",(0,s.jsx)(n.code,{children:"ctx"})," parameter"]}),", so you can access them here. In our case we would like to extend the plugin options with the CLI override:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"const { WebpackManifestPlugin } = require('webpack-manifest-plugin');\n\nclass CliManifestPlugin {\n  //...\n  webpack(config, ctx, imaConfig) {\n    if (ctx.command === 'build') {\n      config.plugins.push(\n        new WebpackManifestPlugin({\n          ...this.#options,\n          // highlight-next-line\n          basePath: ctx.manifestBasePath ?? '',\n        })\n      );\n    }\n\n    return config;\n  }\n  //...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Running ",(0,s.jsx)(n.code,{children:"npx ima build --manifestBasePath=path/prefix"})," should be reflected in the generated ",(0,s.jsx)(n.code,{children:"manifest.json"})," file in the ",(0,s.jsx)(n.code,{children:"./build"})," directory."]}),"\n",(0,s.jsx)(n.h3,{id:"final-results",children:"Final results"}),"\n",(0,s.jsxs)(n.p,{children:["Below is the entire content of the ",(0,s.jsx)(n.code,{children:"ima.config.js"})," file we've been building so far that you can use as a reference."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",metastring:"title=./ima.config.js",children:"const { WebpackManifestPlugin } = require('webpack-manifest-plugin');\n\nclass CliManifestPlugin {\n  #options = {};\n\n  name = 'CliManifestPlugin';\n\n  cliArgs = {\n    dev: undefined, // Dev args will go here\n    build: {\n      manifestBasePath: {\n        desc: 'Overwrite basePath default value',\n        type: 'string',\n      },\n    },\n  };\n\n  constructor(options) {\n    this.#options = options;\n  }\n\n  webpack(config, ctx, imaConfig) {\n    if (ctx.command === 'build') {\n      config.plugins.push(\n        new WebpackManifestPlugin({\n          ...this.#options,\n          basePath: ctx.manifestBasePath ?? '',\n        })\n      );\n    }\n\n    return config;\n  }\n}\n\nconst manifestSeed = {};\n\nmodule.exports = {\n  plugins: [new CliManifestPlugin({ seed: manifestSeed })],\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-typescript",children:"Using TypeScript"}),"\n",(0,s.jsxs)(n.p,{children:["Since the ",(0,s.jsx)(n.code,{children:"@ima/cli"})," is written in TypeScript, there are ",(0,s.jsx)(n.a,{href:"/cli/cli-plugins-api#plugins-api",children:"TypeScript definitions"})," you can use while defining your plugin. All types and interfaces are available as exports from the ",(0,s.jsx)(n.code,{children:"@ima/cli"})," package while you can always have a look at our existing plugins, which are also written in TypeScript for an inspiration."]}),"\n",(0,s.jsx)(n.h2,{id:"existing-cli-plugins",children:"Existing CLI plugins"}),"\n",(0,s.jsxs)(n.p,{children:["Currently we maintain ",(0,s.jsx)(n.strong,{children:"3 distinct CLI plugins"})," that we actively use in our applications. These enables us to extend the feature set of the IMA.js CLI with additional functionality, which is not really suited to be available by default in the original CLI config, since their use is very situational. However you can almost certainly benefit from using these in your application."]}),"\n",(0,s.jsx)(n.p,{children:"Most of these plugins also provide additional functionality that can be used outside of the CLI plugin definition, but it is essential for it to work properly."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/cli/plugins/analyze-plugin",children:(0,s.jsx)(n.strong,{children:"AnalyzePlugin"})})," - Pre-configures ",(0,s.jsx)(n.a,{href:"https://npmjs.com/package/bundle-stats-webpack-plugin",children:"bundle-stats-webpack-plugin"})," and ",(0,s.jsx)(n.a,{href:"https://npmjs.com/package/webpack-bundle-analyzer",children:"webpack-bundle-analyzer"})," webpack plugins for fast and easy bundle analyzing."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/cli/plugins/scramble-css-plugin",children:(0,s.jsx)(n.strong,{children:"ScrambleCSSPlugin"})})," - Implements CSS class minimizer and uglifier that can be reverse-compiled at runtime (you can access classes using their original name)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/cli/plugins/less-constants-plugin",children:(0,s.jsx)(n.strong,{children:"LessConstantsPlugin"})})," - Adds preprocessor which converts theme values defined in the JS file, to their LESS variable counterparts."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},6052:(e,n,i)=>{i.d(n,{A:()=>l});i(3696);var t=i(2689);const s={tabItem:"tabItem_wHwb"};var a=i(2540);function l(e){let{children:n,hidden:i,className:l}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,t.A)(s.tabItem,l),hidden:i,children:n})}},3776:(e,n,i)=>{i.d(n,{A:()=>y});var t=i(3696),s=i(2689),a=i(3707),l=i(9519),r=i(3604),o=i(5196),c=i(6229),u=i(8030);function d(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:s}}=e;return{value:n,label:i,attributes:t,default:s}}))}(i);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function p(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:i}=e;const s=(0,l.W6)(),a=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,o.aZ)(a),(0,t.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function m(e){const{defaultValue:n,queryString:i=!1,groupId:s}=e,a=h(e),[l,o]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a}))),[c,d]=g({queryString:i,groupId:s}),[m,f]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,a]=(0,u.Dv)(i);return[s,(0,t.useCallback)((e=>{i&&a.set(e)}),[i,a])]}({groupId:s}),b=(()=>{const e=c??m;return p({value:e,tabValues:a})?e:null})();(0,r.A)((()=>{b&&o(b)}),[b]);return{selectedValue:l,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),f(e)}),[d,f,a]),tabValues:a}}var f=i(5200);const b={tabList:"tabList_J5MA",tabItem:"tabItem_l0OV"};var x=i(2540);function j(e){let{className:n,block:i,selectedValue:t,selectValue:l,tabValues:r}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),u=e=>{const n=e.currentTarget,i=o.indexOf(n),s=r[i].value;s!==t&&(c(n),l(s))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const i=o.indexOf(e.currentTarget)+1;n=o[i]??o[0];break}case"ArrowLeft":{const i=o.indexOf(e.currentTarget)-1;n=o[i]??o[o.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":i},n),children:r.map((e=>{let{value:n,label:i,attributes:a}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>{o.push(e)},onKeyDown:d,onClick:u,...a,className:(0,s.A)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":t===n}),children:i??n},n)}))})}function w(e){let{lazy:n,children:i,selectedValue:a}=e;const l=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===a));return e?(0,t.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:l.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function v(e){const n=m(e);return(0,x.jsxs)("div",{className:(0,s.A)("tabs-container",b.tabList),children:[(0,x.jsx)(j,{...n,...e}),(0,x.jsx)(w,{...n,...e})]})}function y(e){const n=(0,f.A)();return(0,x.jsx)(v,{...e,children:d(e.children)},String(n))}},3023:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(3696);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);