"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[8844],{7051:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"basic-features/events","title":"Events","description":"Basic features > EventBus and Dispatcher","source":"@site/../docs/basic-features/events.md","sourceDirName":"basic-features","slug":"/basic-features/events","permalink":"/basic-features/events","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/basic-features/events.md","tags":[],"version":"current","lastUpdatedBy":"Jan \u0160ime\u010dek","lastUpdatedAt":1761308686000,"frontMatter":{"title":"Events","description":"Basic features > EventBus and Dispatcher"},"sidebar":"docs","previous":{"title":"Page Manager","permalink":"/basic-features/page-manager"},"next":{"title":"Page State","permalink":"/basic-features/page-state"}}');var i=t(2540),r=t(3023);const o={title:"Events",description:"Basic features > EventBus and Dispatcher"},a=void 0,d={},c=[{value:"EventBus",id:"eventbus",level:2},{value:"Firing EventBus events",id:"firing-eventbus-events",level:3},{value:"Listening to EventBus events",id:"listening-to-eventbus-events",level:3},{value:"Dispatcher",id:"dispatcher",level:2},{value:"Firing and listening to Dispatcher events",id:"firing-and-listening-to-dispatcher-events",level:3},{value:"Listening to all Dispatcher events",id:"listening-to-all-dispatcher-events",level:3},{value:"Observable",id:"observable",level:2},{value:"Subscribing and unsubscribing to events",id:"subscribing-and-unsubscribing-to-events",level:3},{value:"Persistent events",id:"persistent-events",level:3},{value:"Settings",id:"settings",level:3},{value:"Built-in events",id:"built-in-events",level:2},{value:"RouterEvents.<code>BEFORE_HANDLE_ROUTE</code>",id:"routereventsbefore_handle_route",level:3},{value:"RouterEvents.<code>AFTER_HANDLE_ROUTE</code>",id:"routereventsafter_handle_route",level:3},{value:"StateEvents.<code>BEFORE_CHANGE_STATE</code>",id:"stateeventsbefore_change_state",level:3},{value:"StateEvents.<code>AFTER_CHANGE_STATE</code>",id:"stateeventsafter_change_state",level:3},{value:"RendererEvents.<code>MOUNTED</code>",id:"renderereventsmounted",level:3},{value:"RendererEvents.<code>UPDATED</code>",id:"renderereventsupdated",level:3},{value:"RendererEvents.<code>UNMOUNTED</code>",id:"renderereventsunmounted",level:3},{value:"RendererEvents.<code>ERROR</code>",id:"renderereventserror",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Major part of development in JavaScript relies on ",(0,i.jsx)(n.strong,{children:"events"}),". It's easy solution to\nnotify distant instances or React elements scattered across the DOM tree."]}),"\n",(0,i.jsxs)(n.p,{children:["To ease the pain that comes with events, I",(0,i.jsx)(n.strong,{children:"MA.js provides a two utilities that\ntake care of firing and receiving events"}),". Each one with a different style."]}),"\n",(0,i.jsx)(n.h2,{id:"eventbus",children:"EventBus"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ima/event/EventBus"})," allows your UI components to emit custom DOM events\nthat naturally propagate through the DOM tree representing the tree of your UI\ncomponents."]}),"\n",(0,i.jsx)(n.p,{children:"This is used to notify the parent components of user interaction with\ncustom controls in your UI, or to notify the page Controller/Extension itself."}),"\n",(0,i.jsx)(n.p,{children:"The custom events may have any name and carry arbitrary data that are not\nrestricted to JSON-serializable values."}),"\n",(0,i.jsx)(n.h3,{id:"firing-eventbus-events",children:"Firing EventBus events"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EventBus"})," can be used in View and Components via ",(0,i.jsx)(n.code,{children:"fire()"})," method that is\ninherited from ",(0,i.jsx)(n.code,{children:"ima/page/AbstractComponent"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// app/component/expandable/ExpandLink.jsx\n\nonClick(event) {\n  const { expandableId } = this.props;\n  this.fire('expand', { expandableId }); // this will be stopped by ExpandableWrapper\n}\n\nrender() {\n  return (\n  <button onClick = { event => this.onClick(event) }>\n    {\xa0this.props.children }\n  </button>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"listening-to-eventbus-events",children:"Listening to EventBus events"}),"\n",(0,i.jsxs)(n.p,{children:["The opposite for the ",(0,i.jsx)(n.code,{children:"fire()"})," method is ",(0,i.jsx)(n.code,{children:"listen()"})," and ",(0,i.jsx)(n.code,{children:"unlisten()"}),". First\nargument for the ",(0,i.jsx)(n.code,{children:"listen()"})," and ",(0,i.jsx)(n.code,{children:"unlisten()"})," method is an element the listener\nwill be bound to. It can be either DOM element or a React Component that is\nmounted in the DOM tree."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// app/component/expandable/ExpandableWrapper.jsx\n\nconstructor() {\n  this._expandListener = this._expandWrapper.bind(this);\n}\n\ncomponentDidMount() {\n  this.listen(this, 'expand', this._expandListener);\n}\n\ncomponentWillUnmount() {\n  this.unlisten(this, 'expand', this._expandListener);\n}\n\n_expandWrapper(event) {\n  if (event.data.expandableId !== this.expandableId) {\n  return; // this expand event is not meant for us.\n  }\n\n  // Do to propagate the event further.\n  event.stopPropagation();\n\n  // Do the expand!\n}\n\nrender() {\n  return (\n  <div className = 'expandWrapper'>\n    // ... ExpandLink can be nested any level deep. Otherwise we could use simple props callback\n    <ExpandLink expandableId = { this.expandableId }>\n    See more\n    </ExpandLink>\n  </div>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Furthermore, the Controllers and Extensions can easily listen for the events dispatched using\nthe ",(0,i.jsx)(n.code,{children:"EventBus"})," ",(0,i.jsx)(n.em,{children:"(unless the propagation of the event is stopped by a component\nhalf the way)"})," by declaring event listener methods."]}),"\n",(0,i.jsxs)(n.p,{children:["An event listener method is a method of a controller/extension named by the ",(0,i.jsxs)(n.strong,{children:["first-letter\ncapitalized event name with the ",(0,i.jsx)(n.code,{children:"on"})," prefix"]}),", for example the ",(0,i.jsx)(n.code,{children:"formSubmitted"}),"\nevent can be listened for by defining the ",(0,i.jsx)(n.code,{children:"onFormSubmitted()"})," method on your\ncontroller."]}),"\n",(0,i.jsxs)(n.p,{children:["The first argument passed into the controller's or extension's event listener method will be\nthe event data, ",(0,i.jsx)(n.strong,{children:"not the event object itself"}),", as manipulating the event object\nonce it reaches the controller/extension is pointless."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/page/article/ArticleController.js\n\nonExpand({\xa0expandableId }) {\n  // Event never reaches this point because we issued\n  // event.stopPropagation() in ExpandableWrapper.jsx\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can restrict the controller/extension to specific events by setting the ",(0,i.jsx)(n.code,{children:"$name"})," static field\non the controller/extension class. Events with this specific prefix are then applied only to\nthis controller/extension."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/page/article/ArticleController.js\n\nstatic $name = 'ArticleController';\n\nonExpand({\xa0expandableId }) {\n  // Event never reaches this point because we issued\n  // event.stopPropagation() in ExpandableWrapper.jsx\n}\n\n// app/component/expandable/ExpandLink.jsx\n\nonClick(event) {\n  const { expandableId } = this.props;\n  this.fire('ArticleController.expand', { expandableId });\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"dispatcher",children:"Dispatcher"}),"\n",(0,i.jsxs)(n.p,{children:["The obvious limitation of the ",(0,i.jsx)(n.code,{children:"ima/event/EventBus"})," API is that it only allows\nto create events that propagate up the tree of the UI components. The common\nway to propagate event in other directions, or to other parts of the UI, or\nfrom the controller to the UI is using the ",(0,i.jsx)(n.code,{children:"app/event/Dispatcher"})," API."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Accessing Dispatcher in Controllers"})," is easy with ",(0,i.jsx)(n.a,{href:"/basic-features/object-container#1-dependency-injection",children:"Dependency Injection"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"firing-and-listening-to-dispatcher-events",children:"Firing and listening to Dispatcher events"}),"\n",(0,i.jsxs)(n.p,{children:["The Dispatcher allows any UI component and controller to register and deregister\nevent listeners for arbitrarily named events using ",(0,i.jsx)(n.code,{children:"listen()"})," and ",(0,i.jsx)(n.code,{children:"unlisten()"}),"\nmethods and fire these events with arbitrary data using ",(0,i.jsx)(n.code,{children:"fire()"})," method."]}),"\n",(0,i.jsx)(n.p,{children:"Events propagate directly to the registered event listeners with no way to stop\ntheir propagation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/component/image/Image.jsx\n\nonImageClick(event) {\n  event.preventDefault();\n\n  const {\xa0image } = this.props;\n  this.utils.$Dispatcher.fire('showLightbox', { image });\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/component/lightbox/Lightbox.jsx\n\ncomponentDidMount() {\n  this.utils.$Dispatcher.listen('showLightbox', this.onLightboxShow, this);\n}\n\ncomponentWillUnmount() {\n  this.utils.$Dispatcher.unlisten('showLightbox', this.onLightboxShow, this);\n}\n\nonLightboxShow(data) {\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Lightbox component can be mounted anywhere in the DOM tree and it\nwill still receive the ",(0,i.jsx)(n.code,{children:"showLightbox"})," event when it's fired."]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," A great place to\nmount components like Lightbox is ",(0,i.jsx)(n.a,{href:"/basic-features/rendering-process#managedrootview",children:"ManagedRootView"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"listening-to-all-dispatcher-events",children:"Listening to all Dispatcher events"}),"\n",(0,i.jsxs)(n.p,{children:["You can listen to all events dispatched by the ",(0,i.jsx)(n.code,{children:"Dispatcher"})," by using the ",(0,i.jsx)(n.code,{children:"listenAll()"}),"\nand ",(0,i.jsx)(n.code,{children:"unlistenAll()"})," methods."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/component/eventLogger/EventLogger.jsx\n\ncomponentDidMount() {\n  this.utils.$Dispatcher.listenAll(this._onDispatcherEvent, this);\n}\n\ncomponentWillUnmount() {\n  this.utils.$Dispatcher.unlistenAll(this._onDispatcherEvent, this);\n}\n\n_onDispatcherEvent(eventName, data) {\n  // ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"observable",children:"Observable"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Observable"})," class allows you to subscribe to events dispatched by the\n",(0,i.jsx)(n.code,{children:"Dispatcher"}),". Upon subscribing, subscribers will be notified of past and future\nevents."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Accessing Observable in Controllers"})," is easy with ",(0,i.jsx)(n.a,{href:"/basic-features/object-container#1-dependency-injection",children:"Dependency Injection"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"subscribing-and-unsubscribing-to-events",children:"Subscribing and unsubscribing to events"}),"\n",(0,i.jsxs)(n.p,{children:["You can subscribe to events dispatched by the ",(0,i.jsx)(n.code,{children:"Dispatcher"})," using the ",(0,i.jsx)(n.code,{children:"subscribe()"}),", and unsubscribe using the ",(0,i.jsx)(n.code,{children:"unsubscribe()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/component/media/Media.jsx\n\ncomponentDidMount() {\n  this.utils.$Observable.subscribe('showLightbox', this._onShowLightbox, this);\n}\n\ncomponentWillUnmount() {\n  this.utils.$Observable.unsubscribe('showLightbox', this._onShowLightbox, this);\n}\n\n_onShowLightbox(data) {\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," If the ",(0,i.jsx)(n.code,{children:"showLightbox"})," event was already dispatched before the ",(0,i.jsx)(n.code,{children:"Media"})," component was mounted,\nthe ",(0,i.jsx)(n.code,{children:"_onShowLightbox"})," method will be called immediately upon subscribing with the data that was passed to the event.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Note:"})," If the event was dispatched multiple times before the ",(0,i.jsx)(n.code,{children:"Media"})," component was mounted,\nthe ",(0,i.jsx)(n.code,{children:"_onShowLightbox"})," method will be called for each event."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"persistent-events",children:"Persistent events"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Observable"})," class clears its history of dispatched events when the ",(0,i.jsx)(n.code,{children:"RouterEvents.BEFORE_HANDLE_ROUTE"})," event is dispatched.\nIf you want to keep the history of dispatched events, you can use the ",(0,i.jsx)(n.code,{children:"registerPersistentEvent()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/config/services.js\n\nexport const initServicesApp = (ns, oc, config) => {\n  const Observable = oc.get('$Observable');\n\n  Observable.registerPersistentEvent('scriptLoaded');\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"settings",children:"Settings"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"Observable"})," class holds the last 10 events dispatched by the ",(0,i.jsx)(n.code,{children:"Dispatcher"}),".\nYou can change this by modifying the ",(0,i.jsx)(n.code,{children:"$Observable.maxHistoryLength"})," setting."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/config/settings.js\n\nexport default (ns, oc, config) => {\n  return {\n    prod: {\n      // ...\n      $Observable: {\n        maxHistoryLength: 20\n      }\n    }\n  };\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"built-in-events",children:"Built-in events"}),"\n",(0,i.jsxs)(n.p,{children:["IMA.js fires a few events that let you know that something has happened under\nthe hood. You can listen to these events using ",(0,i.jsx)(n.strong,{children:"Dispatcher"}),"'s listen method."]}),"\n",(0,i.jsxs)(n.h3,{id:"routereventsbefore_handle_route",children:["RouterEvents.",(0,i.jsx)(n.code,{children:"BEFORE_HANDLE_ROUTE"})]}),"\n",(0,i.jsx)(n.p,{children:"This event is fired after the router matches new url to a registered route and\nbefore the page change starts. The data passed with the event look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"{\n  // the new Route instance\n  route,\n  // new URL parameters\n  params,\n  // the path portion of the new URL (a route definition is matched against this)\n  path,\n  // route options extended of options provided to the function\n  // that triggered the routing\n  options,\n  // an action object describing what triggered the routing\n  // if a PopStateEvent triggered the routing the action object will\n  // look like this { type: 'popstate', event: PopStateEvent }\n  // otherwise the event will be MouseEvent (e.g. clicked on a link)\n  // and type will be either 'redirect', 'click' or 'error'.\n  action\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"routereventsafter_handle_route",children:["RouterEvents.",(0,i.jsx)(n.code,{children:"AFTER_HANDLE_ROUTE"})]}),"\n",(0,i.jsxs)(n.p,{children:["This event is contrary to the ",(0,i.jsx)(n.code,{children:"BEFORE_HANDLE_ROUTE"}),". It's fired with the same\ndata but after the page was changed."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," The ",(0,i.jsx)(n.code,{children:"AFTER_HANDLE_ROUTE"})," event will be fired regardless if promises\nloaded be the new Controller are resolved."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"stateeventsbefore_change_state",children:["StateEvents.",(0,i.jsx)(n.code,{children:"BEFORE_CHANGE_STATE"})]}),"\n",(0,i.jsx)(n.p,{children:"An event fired before the page state changes. The handler of this event receives\nfollowing data:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"{\n  // The state object derived from the oldState and patchState\n  newState,\n  // The current state\n  oldState,\n  // The data that were passed to the `setState` method\n  patchState\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," You can mutate the ",(0,i.jsx)(n.code,{children:"newState"})," object if you wish. Mutating\n",(0,i.jsx)(n.code,{children:"oldState"})," and ",(0,i.jsx)(n.code,{children:"patchState"})," will have no effect."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"stateeventsafter_change_state",children:["StateEvents.",(0,i.jsx)(n.code,{children:"AFTER_CHANGE_STATE"})]}),"\n",(0,i.jsxs)(n.p,{children:["An event fired after the page state changes. The data passed with this event\ncontain only the ",(0,i.jsx)(n.code,{children:"newState"})," object."]}),"\n",(0,i.jsxs)(n.h3,{id:"renderereventsmounted",children:["RendererEvents.",(0,i.jsx)(n.code,{children:"MOUNTED"})]}),"\n",(0,i.jsxs)(n.p,{children:["PageRenderer fires this event after current page view is mounted to the DOM. Event's data contain ",(0,i.jsx)(n.code,{children:"{ type: String }"})," Where type can be one of constants located in ",(0,i.jsx)(n.code,{children:"@ima/core/page/renderer/Types"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"renderereventsupdated",children:["RendererEvents.",(0,i.jsx)(n.code,{children:"UPDATED"})]}),"\n",(0,i.jsxs)(n.p,{children:["PageRenderer fires this event after current state is updated in the DOM. Event's data contain ",(0,i.jsx)(n.code,{children:"{ state: Object<string, *>}"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"renderereventsunmounted",children:["RendererEvents.",(0,i.jsx)(n.code,{children:"UNMOUNTED"})]}),"\n",(0,i.jsxs)(n.p,{children:["PageRenderer fires this event after current view is unmounted from the DOM. Event's data contain ",(0,i.jsx)(n.code,{children:"{ type: String }"})," Where type can be one of constants located in ",(0,i.jsx)(n.code,{children:"@ima/core/page/renderer/Types"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"renderereventserror",children:["RendererEvents.",(0,i.jsx)(n.code,{children:"ERROR"})]}),"\n",(0,i.jsxs)(n.p,{children:["PageRenderer fires this event when there is no _viewContainer in _renderToDOM method. Event's data contain ",(0,i.jsx)(n.code,{children:"{ message: string }"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},3023:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(3696);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);