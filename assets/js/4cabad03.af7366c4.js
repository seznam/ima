"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[3097],{9091:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"plugins/plugin-api","title":"Plugins API","description":"Plugins > Plugins API","source":"@site/../docs/plugins/plugin-api.md","sourceDirName":"plugins","slug":"/plugins/plugin-api","permalink":"/plugins/plugin-api","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/plugins/plugin-api.md","tags":[],"version":"current","lastUpdatedBy":"Jan \u0160ime\u010dek","lastUpdatedAt":1761308686000,"frontMatter":{"title":"Plugins API","description":"Plugins > Plugins API"},"sidebar":"docs","previous":{"title":"Events","permalink":"/server/events"},"next":{"title":"Existing plugins","permalink":"/plugins/available-plugins"}}');var s=i(2540),r=i(3023);const o={title:"Plugins API",description:"Plugins > Plugins API"},a=void 0,l={},c=[{value:"Plugin registration",id:"plugin-registration",level:2},{value:"Plugin bootstrap functions",id:"plugin-bootstrap-functions",level:3},{value:"initBind",id:"initbind",level:4},{value:"initServices",id:"initservices",level:4},{value:"initSettings",id:"initsettings",level:4},{value:"Settings merging",id:"settings-merging",level:3},{value:"Examples",id:"examples",level:3},{value:"Dynamically imported plugins and tree shaking",id:"dynamically-imported-plugins-and-tree-shaking",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["IMA.js development stack offers ",(0,s.jsx)(n.strong,{children:"built-in support for plugins"}),". Writing plugins for IMA.js is really\nsimple. It basically comes to creating an ordinary npm package and using ",(0,s.jsx)(n.code,{children:"pluginLoader.register"})," method to hook into IMA.js application environment using certain functions."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"In situations where you don't need to hook into IMA.js app environment from within your plugin (you're for example just exporting some interface), you don't need call this registration method as it servers no purpose."})}),"\n",(0,s.jsx)(n.h2,{id:"plugin-registration",children:"Plugin registration"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned above, the plugin registration is done from within your ",(0,s.jsx)(n.strong,{children:"npm package entry point"})," using ",(0,s.jsx)(n.code,{children:"pluginLoader.register"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { pluginLoader } from '@ima/core';\nimport Service from './service';\n\npluginLoader.register('my-ima-plugin', ns => {\n  ns.set('my.ima.plugin.Service', Service);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"register"})," method expects 2 arguments, first is ",(0,s.jsx)(n.strong,{children:"name of your plugin"})," (this is used strictly for debugging purposes, however it is required) and ",(0,s.jsx)(n.strong,{children:"callback registration function"})," which receives ",(0,s.jsx)(n.a,{href:"../api/modules/ima_core.md#ns",children:(0,s.jsx)(n.code,{children:"Namespace"})})," as one and only argument, that you can use to specify to which namespace this plugin should be bound."]}),"\n",(0,s.jsx)(n.h3,{id:"plugin-bootstrap-functions",children:"Plugin bootstrap functions"}),"\n",(0,s.jsxs)(n.p,{children:["The registration function can additionally ",(0,s.jsx)(n.strong,{children:"return an object with additional callback functions"}),". These allow you to further bootstrap your plugin. All are however optional, meaning you can define any combination of these or don't return anything."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { pluginLoader } from '@ima/core';\n\npluginLoader.register('my-ima-plugin', ns => {\n  return {\n    initBind: (ns, oc, config) => {},\n    initServices: (ns, oc, config) => {},\n    initSettings: (ns, oc, config) => {}\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"initbind",children:"initBind"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"initBind(ns: Namespace, oc: ObjectContainer, config: Config['bind'], isDynamicallyLoaded = false)"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This function has the same interface as a function exported in ",(0,s.jsx)(n.code,{children:"bind.js"})," of your IMA.js application and also serves the same purpose. This is the place where you would want to initialize your custom constants and bindings and assign them to the ",(0,s.jsx)(n.a,{href:"/basic-features/object-container",children:(0,s.jsx)(n.code,{children:"ObjectContainer"})}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"initservices",children:"initServices"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"initServices(ns: Namespace, oc: ObjectContainer, config: Config['services'], isDynamicallyLoaded = false)"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly to ",(0,s.jsx)(n.code,{children:"initBind"}),", this is equivalent to a function exported by ",(0,s.jsx)(n.code,{children:"services.js"})," file in your application."]}),"\n",(0,s.jsx)(n.h4,{id:"initsettings",children:"initSettings"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"initSettings(ns: Namespace, oc: ObjectContainer, config: Config['settings'], isDynamicallyLoaded = false)"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can probably already see the pattern here. This function should return an object with settings, with the same structure as function in ",(0,s.jsx)(n.code,{children:"settings.js"})," file does."]}),"\n",(0,s.jsxs)(n.p,{children:["These settings are then ",(0,s.jsx)(n.strong,{children:"merged with your application settings"})," a possible conflicts are overridden with the application settings. This allows you to ",(0,s.jsx)(n.strong,{children:"define defaults for your plugin"}),", which can be easily overridden in your application."]}),"\n",(0,s.jsx)(n.h3,{id:"settings-merging",children:"Settings merging"}),"\n",(0,s.jsxs)(n.p,{children:["When instead of overriding, you want to transform the existing values of settings, you may use the helper ",(0,s.jsx)(n.code,{children:"assignTransformation()"})," from ",(0,s.jsx)(n.code,{children:"@ima/helpers"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"It allows you to provide a custom transformation function that will replace the behaviour of the assign function that overrides the old values with new ones. It accepts a callback function that will be invoked as a transformation when merging settings."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"assignTransformation(callbackFunction: (value) => typeof value);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example use case might be adding new values to an existing array:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"return {\n    enviroment: {\n        ...\n        entitiesWithContent: assignTransformation((value) => [...value, 'additional value']),\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.p,{children:["Putting it all together, your main file in your npm package could look something like this (borrowing contents of ",(0,s.jsx)(n.code,{children:"main.js"})," from our ",(0,s.jsx)(n.a,{href:"https://github.com/seznam/IMA.js-plugins/blob/master/packages/plugin-useragent/README.md",children:"@ima/plugin-useragent"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { pluginLoader } from '@ima/core';\nimport PlatformJS from 'platform';\n\nimport UserAgent from './AbstractUserAgent.js';\nimport ClientUserAgent from './ClientUserAgent.js';\nimport ServerUserAgent from './ServerUserAgent.js';\n\npluginLoader.register('@ima/plugin-useragent', () => {\n  return {\n    initBind: (ns, oc) => {\n      if (oc.get('$Window').isClient()) {\n        oc.provide(UserAgent, ClientUserAgent, [PlatformJS, '$Window']);\n      } else {\n        oc.provide(UserAgent, ServerUserAgent, [PlatformJS, '$Request']);\n      }\n    },\n    initServices: (ns, oc) => {\n      oc.get(UserAgent).init();\n    },\n  };\n});\n\nexport { ClientUserAgent, ServerUserAgent, UserAgent, PlatformJS };\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dynamically-imported-plugins-and-tree-shaking",children:"Dynamically imported plugins and tree shaking"}),"\n",(0,s.jsxs)(n.p,{children:["When the plugin is imported dynamically and initialized lazily, you receive ",(0,s.jsx)(n.code,{children:"isDynamicallyLoaded = true"})," as the last argument in the registration bootstrap functions. This can help you in certain situations where you need to know when the plugin was initialized."]}),"\n",(0,s.jsxs)(n.p,{children:["The bootstrap process works the same way as with plugins initialized upon application startup, meaning all plugin settings are still overwritten with possible overrides in the application settings. There's however one caveat with the ",(0,s.jsx)(n.code,{children:"ObjectContainer"})," that you need to pay attention to."]}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.strong,{children:"string syntax"})," to get certain settings in the ",(0,s.jsx)(n.code,{children:"$dependencies"})," field:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"static get $dependencies() {\n  return ['$Settings.myPlugin.repeatCount'];\n};\n\nconstructor(repeatCount) {\n  this.repeatCount = repeatCount;\n}\n\nfn() {\n  this.repeatXTimes(this.repeatCount);\n}\n"})}),(0,s.jsxs)(n.p,{children:["This w",(0,s.jsx)(n.strong,{children:"on't be updated"})," with possible plugin defaults when it get's loaded. In order to prevent this issue, you need to access whole settings object which will get updated values:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"static get $dependencies() {\n  return ['$Settings'];\n};\n\nmyFUnction(settings) {\n  this.settings = settings;\n}\n\nfn() {\n  this.repeatXTimes(settings?.myPlugin?.repeatCount);\n}\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, creating IMA.js plugin is very easy. You can always check our\n",(0,s.jsx)(n.a,{href:"https://github.com/seznam/IMA.js-plugins/tree/master",children:"IMA.js-plugins"})," monorepo to take a look at many other already\nexisting plugins and how they're implemented, which we describe more in detail ",(0,s.jsx)(n.a,{href:"./available-plugins",children:"in the documentation"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3023:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(3696);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);