"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[3864],{192:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"basic-features/controller-lifecycle","title":"Controller lifecycle","description":"Basic features > Controller lifecycle and it\'s API","source":"@site/../docs/basic-features/controller-lifecycle.md","sourceDirName":"basic-features","slug":"/basic-features/controller-lifecycle","permalink":"/basic-features/controller-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/basic-features/controller-lifecycle.md","tags":[],"version":"current","lastUpdatedBy":"Jan \u0160ime\u010dek","lastUpdatedAt":1761308686000,"frontMatter":{"title":"Controller lifecycle","description":"Basic features > Controller lifecycle and it\'s API"},"sidebar":"docs","previous":{"title":"Configuration options","permalink":"/introduction/configuration"},"next":{"title":"Views & Components","permalink":"/basic-features/views-and-components"}}');var s=n(2540),i=n(3023);const c={title:"Controller lifecycle",description:"Basic features > Controller lifecycle and it's API"},l=void 0,o={},a=[{value:"<code>init()</code> <em>@server/client</em>",id:"init-serverclient",level:2},{value:"<code>load()</code> <em>@server/client</em>",id:"load-serverclient",level:2},{value:"<code>setMetaParams()</code> <em>@server/client</em>",id:"setmetaparams-serverclient",level:2},{value:"<code>activate()</code> <em>@client</em>",id:"activate-client",level:2},{value:"<code>update()</code> <em>@client</em>",id:"update-client",level:2},{value:"<code>deactivate()</code> <em>@client</em>",id:"deactivate-client",level:2},{value:"<code>destroy()</code> <em>@client</em>",id:"destroy-client",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["IMA.js ",(0,s.jsx)(t.strong,{children:"AbstractController"})," provides a few methods you can implement in order to catch various lifecycle events and react to them. Each method description has ",(0,s.jsx)(t.em,{children:"@server"})," or ",(0,s.jsx)(t.em,{children:"@client"}),"\xa0notation next to them symbolizing where the method is executed."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{src:n(1325).A+"",width:"881",height:"421"})}),"\n",(0,s.jsxs)(t.h2,{id:"init-serverclient",children:[(0,s.jsx)(t.code,{children:"init()"})," ",(0,s.jsx)(t.em,{children:"@server/client"})]}),"\n",(0,s.jsxs)(t.p,{children:["This is the first method that gets called in the lifecycle chain. Init method is substitution for native ",(0,s.jsx)(t.code,{children:"constructor()"})," method. Route parameters are already set when this method is called."]}),"\n",(0,s.jsxs)(t.h2,{id:"load-serverclient",children:[(0,s.jsx)(t.code,{children:"load()"})," ",(0,s.jsx)(t.em,{children:"@server/client"})]}),"\n",(0,s.jsx)(t.p,{children:"Callback the controller uses to load all resources it needs to render a view."}),"\n",(0,s.jsxs)(t.p,{children:["The method must return a plain flat object that will be used to set the state of the controller. The field names of the object identify the resources being fetched and prepared, each value must be either the resource (e.g. view configuration or a value retrieved synchronously) or a ",(0,s.jsx)(t.code,{children:"Promise"})," that will resolve to the resource."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Promise"}),"s are handled differently when rendering on the server side or the client side."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["At the ",(0,s.jsx)(t.strong,{children:"server side"}),", the IMA will wait for all the promises to resolve, then replace the promises with the resolved values and sets the resulting object as the controller's state. Even though promises are resolved in parallel it's a good practice to keep their number on minimum because their resolution is blocking sending the response to the client."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["At the ",(0,s.jsx)(t.strong,{children:"client side"}),", the IMA.js will first set the controller's state to\nan object containing only the fields of the returned object that were\n",(0,s.jsx)(t.strong,{children:"not promises"}),". IMA will then update the controller's state every time a\npromise of the returned object resolves."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Any returned promise that gets ",(0,s.jsx)(t.strong,{children:"rejected"})," will redirect the application to\nthe error page. The error page that will be used depends on the status\ncode of the error."]}),"\n",(0,s.jsxs)(t.p,{children:["Since ",(0,s.jsx)(t.strong,{children:"v17"})," you can use ",(0,s.jsx)(t.code,{children:"async/await"})," instead of promises. This means the ",(0,s.jsx)(t.code,{children:"load"})," method will have ",(0,s.jsx)(t.strong,{children:"async"})," prefix and resources will be loaded synchronously using ",(0,s.jsx)(t.strong,{children:"await"})," keyword."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"async load() {\n  const user = await this._userService.getById(this.params.userId);\n  const comments = await this._commentService.list({ userId: user.id });\n\n  return {\n    user,\n    comments\n  };\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This functionality has its pros and cons. Main contradiction would be synchronous loading and thus response time increase. A lot of requests can happen independently on each other and save some of the response time. In this case it's better to combine promises and ",(0,s.jsx)(t.code,{children:"async/await"})," to achieve best performance."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"async load() {\n  const userPromise = this._userService.getById(this.params.userId); // load parallel to article and comments\n  const article = await this._articleService.get(this.params.articleUrl);\n  let comments = [];\n\n  if (article.commentsCount && article.commentsAllowed) {\n    comments = await this._commentService.list({\xa0articleId: article.id });\n  }\n\n  return { article, comments, user: userPromise };\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["A benefit to using ",(0,s.jsx)(t.strong,{children:"async/await"})," is simplicity and better handling of data. Imagine you have a request that loads 2 resources and you want to add these resources to page state. When using promises this would be impossible as promises must return single value and we're returning the promise itself not the resolved value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"async load() {\n  const checkoutData = await this._checkoutService.getByCookie();\n  const { items, payment, shipping } = checkoutData;\n\n  return {\n    cartItems: items,\n    paymentDetails: payment,\n    shippingDetail: shipping\n  };\n}\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"setmetaparams-serverclient",children:[(0,s.jsx)(t.code,{children:"setMetaParams()"})," ",(0,s.jsx)(t.em,{children:"@server/client"})]}),"\n",(0,s.jsxs)(t.p,{children:["Callback used to configure the meta attribute manager. The method is\ncalled after the controller's state has been patched with the all\nloaded resources from the ",(0,s.jsx)(t.a,{href:"#load-serverclient",children:(0,s.jsx)(t.code,{children:"load()"})})," method and the view has been rendered."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"setMetaParams()"})," method receives following arguments:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"loadedResources"})," - A plain object representing a map of resource names to resources loaded by the ",(0,s.jsx)(t.a,{href:"#load-serverclient",children:(0,s.jsx)(t.code,{children:"load()"})})," method. This is the same object as the one passed to the ",(0,s.jsx)(t.code,{children:"setState()"})," method."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"metaManager"})," - Meta attributes manager instance to configure (See ",(0,s.jsx)(t.a,{href:"./seo-and-meta-manager",children:"SEO & MetaManager"})," page)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"router"})," - The current application router."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"dictionary"})," - The current localization dictionary"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"settings"})," - The application settings for the current application environment."]}),"\n"]}),"\n",(0,s.jsxs)(t.h2,{id:"activate-client",children:[(0,s.jsx)(t.code,{children:"activate()"})," ",(0,s.jsx)(t.em,{children:"@client"})]}),"\n",(0,s.jsxs)(t.p,{children:["Callback for activating the controller when the ",(0,s.jsx)(t.strong,{children:"route updated"})," to one of those that are associated with the controller or the controller is ",(0,s.jsx)(t.strong,{children:"revived"})," at the client side."]}),"\n",(0,s.jsxs)(t.p,{children:["This method is the last method invoked during controller initialization. ",(0,s.jsx)(t.code,{children:"activate()"})," is called after all the promises returned from the ",(0,s.jsx)(t.a,{href:"#load-serverclient",children:(0,s.jsx)(t.code,{children:"load()"})})," method have been resolved and the controller has configured the meta manager."]}),"\n",(0,s.jsxs)(t.p,{children:["When reviving the state from the ",(0,s.jsx)(t.strong,{children:"server side"}),"\xa0all promises are resolved and meta values set, therefore the controller state is fully complete."]}),"\n",(0,s.jsx)(t.p,{children:"This method is a good place to register any React and DOM event listeners. The controller may start receiving event bus event after this method completes."}),"\n",(0,s.jsxs)(t.h2,{id:"update-client",children:[(0,s.jsx)(t.code,{children:"update()"})," ",(0,s.jsx)(t.em,{children:"@client"})]}),"\n",(0,s.jsxs)(t.p,{children:["Callback for updating the controller after a route update. This method\nis invoked if the current ",(0,s.jsxs)(t.a,{href:"/basic-features/routing/introduction#onlyupdate",children:["route has the ",(0,s.jsx)(t.code,{children:"onlyUpdate = true"})," flag set"]})," and the current controller and view match those used by the previously active route, or, the ",(0,s.jsx)(t.code,{children:"onlyUpdate"})," option of the current route is a callback and returned ",(0,s.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The method must return an object with the same semantics as the result\nof the ",(0,s.jsx)(t.a,{href:"#load-serverclient",children:(0,s.jsx)(t.code,{children:"load()"})})," method. The controller's state will only be\npatched by the returned object instead of replacing it completely."]}),"\n",(0,s.jsxs)(t.p,{children:["The other controller lifecycle callbacks (",(0,s.jsx)(t.a,{href:"#init--serverclient",children:(0,s.jsx)(t.code,{children:"init()"})}),", ",(0,s.jsx)(t.a,{href:"#load-serverclient",children:(0,s.jsx)(t.code,{children:"load()"})}),", ",(0,s.jsx)(t.a,{href:"#activate--client",children:(0,s.jsx)(t.code,{children:"activate()"})}),", ",(0,s.jsx)(t.a,{href:"#deactivate--client",children:(0,s.jsx)(t.code,{children:"deactivate()"})}),", ",(0,s.jsx)(t.a,{href:"#destroy--client",children:(0,s.jsx)(t.code,{children:"destroy()"})}),") are not call in case this method is used."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"update()"})," method receives argument ",(0,s.jsx)(t.strong,{children:"prevParams"}),"; an object containing previous route parameters."]}),"\n",(0,s.jsxs)(t.h2,{id:"deactivate-client",children:[(0,s.jsx)(t.code,{children:"deactivate()"})," ",(0,s.jsx)(t.em,{children:"@client"})]}),"\n",(0,s.jsx)(t.p,{children:"Callback for deactivating the controller. This is the first\nmethod invoked during controller deinitialization. This usually happens\nwhen the user navigates to a different URL."}),"\n",(0,s.jsxs)(t.p,{children:["This method is the lifecycle counterpart of the ",(0,s.jsx)(t.a,{href:"#activate--client",children:(0,s.jsx)(t.code,{children:"activate()"})})," method. When the ",(0,s.jsx)(t.a,{href:"#activate--client",children:(0,s.jsx)(t.code,{children:"activate()"})})," method has not been called ",(0,s.jsx)(t.code,{children:"deactivate()"})," won't be called either."]}),"\n",(0,s.jsxs)(t.p,{children:["The controller should deregister listeners and release all\nresources obtained in the ",(0,s.jsx)(t.a,{href:"#activate--client",children:(0,s.jsx)(t.code,{children:"activate()"})})," method."]}),"\n",(0,s.jsxs)(t.h2,{id:"destroy-client",children:[(0,s.jsx)(t.code,{children:"destroy()"})," ",(0,s.jsx)(t.em,{children:"@client"})]}),"\n",(0,s.jsx)(t.p,{children:"Finalization callback, called when the controller is being discarded by the application. This usually happens when the user navigates to a different URL."}),"\n",(0,s.jsxs)(t.p,{children:["This method is the lifecycle counterpart of the ",(0,s.jsx)(t.a,{href:"#init--serverclient",children:(0,s.jsx)(t.code,{children:"init()"})})," method."]}),"\n",(0,s.jsxs)(t.p,{children:["The controller should release all resources obtained in the ",(0,s.jsx)(t.a,{href:"#init--serverclient",children:(0,s.jsx)(t.code,{children:"init()"})})," method. The controller must release any resources that might not be released automatically when the controller's instance\nis destroyed by the garbage collector."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1325:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/diagram-controller-64b259a163b3fe8df2ec36327342a103.png"},3023:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>l});var r=n(3696);const s={},i=r.createContext(s);function c(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);