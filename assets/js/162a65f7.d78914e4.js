"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[3403],{2874:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"basic-features/page-manager","title":"Page Manager","description":"Basic features > Page Manager and app rendering","source":"@site/../docs/basic-features/page-manager.md","sourceDirName":"basic-features","slug":"/basic-features/page-manager","permalink":"/basic-features/page-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/basic-features/page-manager.md","tags":[],"version":"current","lastUpdatedBy":"Ji\u0159\xed Fencl","lastUpdatedAt":1743072967000,"frontMatter":{"title":"Page Manager","description":"Basic features > Page Manager and app rendering"},"sidebar":"docs","previous":{"title":"Handling scripts and styles","permalink":"/basic-features/handling-scripts-and-styles"},"next":{"title":"Events","permalink":"/basic-features/events"}}');var t=r(2540),i=r(3023);const s={title:"Page Manager",description:"Basic features > Page Manager and app rendering"},o=void 0,d={},l=[{value:"Managing process",id:"managing-process",level:2},{value:"Intervene into the process",id:"intervene-into-the-process",level:2},{value:"PageManagerHandlers",id:"pagemanagerhandlers",level:3},{value:"1. <code>init()</code> method",id:"1-init-method",level:4},{value:"2. <code>handlePreManagedState()</code> method",id:"2-handlepremanagedstate-method",level:4},{value:"3. <code>handlePostManagedState()</code> method",id:"3-handlepostmanagedstate-method",level:4},{value:"4. <code>destroy()</code> method",id:"4-destroy-method",level:4},{value:"Registering PageManagerHandlers",id:"registering-pagemanagerhandlers",level:2},{value:"PageNavigationHandler",id:"pagenavigationhandler",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Page Manager is an essential part of IMA.js. It's something like a puppeteer that manipulates with pages and views. Once a router matches URL to one of route's path the page manager takes care of the rest."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:r(7346).A+"",width:"881",height:"421"})}),"\n",(0,t.jsx)(n.h2,{id:"managing-process",children:"Managing process"}),"\n",(0,t.jsxs)(n.p,{children:["If the new matched route has ",(0,t.jsxs)(n.a,{href:"./routing/introduction#onlyupdate",children:[(0,t.jsx)(n.code,{children:"onlyUpdate"})," option"]})," set to ",(0,t.jsx)(n.code,{children:"true"})," and the controller and view hasn't changed the route transition is dispatched only through ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#update-client",children:[(0,t.jsx)(n.code,{children:"update"})," method"]})," of the controller."]}),"\n",(0,t.jsx)(n.p,{children:"In every other case the manager goes through it's full process:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Unload previous controller and extensions"})," - To make room for the new, manager has to get rid of the old controller and extensions. First calls ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#deactivate-client",children:[(0,t.jsx)(n.code,{children:"deactivate"})," method"]})," on every extension registered in the old controller and then the same method on the controller itself.\nSame process follows with ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#destroy-client",children:[(0,t.jsx)(n.code,{children:"destroy"})," method"]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clear state and unmount view"})," - After unloading controller and extensions the page state is cleared and view (starting from ",(0,t.jsx)(n.a,{href:"./rendering-process#managedrootview",children:"ManagedRootView"}),") is unmounted. However if the ",(0,t.jsx)(n.a,{href:"./rendering-process#documentview",children:"DocumentView"}),", ",(0,t.jsx)(n.a,{href:"./rendering-process#viewadapter",children:"ViewAdapter"})," and ",(0,t.jsx)(n.a,{href:"./rendering-process#managedrootview",children:"ManagedRootView"})," are the same for the new route the view is cleared rather then unmounted. This way you can achieve component persistency."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Loading new controller and extensions"})," - After the manager is done with clearing previous resource it initializes the new ones. First the ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#init-serverclient",children:[(0,t.jsx)(n.code,{children:"init"})," method"]})," is called on controller then on every extension (Extensions may ",(0,t.jsx)(n.a,{href:"./extensions#how-to-use-extensions",children:"be initialized"})," during the controllers ",(0,t.jsx)(n.code,{children:"init"})," method call).\nWhen the initialization is complete manager starts loading resources via ",(0,t.jsx)(n.code,{children:"load"})," method of the controller and extensions. For detailed explanation see the ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#load-serverclient",children:[(0,t.jsx)(n.code,{children:"load"})," method documentation"]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Rendering new view"})," - After the ",(0,t.jsx)(n.code,{children:"load"})," method has been called a view for the controller is rendered. It doesn't matter if all promises returned by the ",(0,t.jsx)(n.code,{children:"load"})," method have been resolved. The process of handling promises is described in the ",(0,t.jsxs)(n.a,{href:"./controller-lifecycle#load-serverclient",children:[(0,t.jsx)(n.code,{children:"load"})," method documentation"]}),".  Following rendering process is described on a page ",(0,t.jsx)(n.a,{href:"./rendering-process",children:"Rendering process"})," and ",(0,t.jsx)(n.a,{href:"./views-and-components",children:"View & Components"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"intervene-into-the-process",children:"Intervene into the process"}),"\n",(0,t.jsxs)(n.p,{children:["It's possible for you to intervene into the process before it starts and after it finished. One way is to listen to ",(0,t.jsx)(n.a,{href:"./events#built-in-events",children:(0,t.jsx)(n.code,{children:"BEFORE_HANDLE_ROUTE"})})," and ",(0,t.jsx)(n.a,{href:"./events#built-in-events",children:(0,t.jsx)(n.code,{children:"AFTER_HANDLE_ROUTE"})})," dispatcher events. However from inside event listeners you cannot intercept or modify the process. For this purpose we've introduced PageManagerHandlers in ",(0,t.jsx)(n.a,{href:"/migration/migration-0.16.0",children:"v16"})]}),"\n",(0,t.jsx)(n.h3,{id:"pagemanagerhandlers",children:"PageManagerHandlers"}),"\n",(0,t.jsxs)(n.p,{children:["PageManagerHandler is a simple class that extends ",(0,t.jsx)(n.code,{children:"ima/page/handler/PageHandler"}),". It can obtain dependencies through ",(0,t.jsx)(n.a,{href:"./object-container#1-dependency-injection",children:"dependency injection"}),". Each handler should contain 4 methods:"]}),"\n",(0,t.jsxs)(n.h4,{id:"1-init-method",children:["1. ",(0,t.jsx)(n.code,{children:"init()"})," method"]}),"\n",(0,t.jsx)(n.p,{children:"For purpose of initializing."}),"\n",(0,t.jsxs)(n.h4,{id:"2-handlepremanagedstate-method",children:["2. ",(0,t.jsx)(n.code,{children:"handlePreManagedState()"})," method"]}),"\n",(0,t.jsxs)(n.p,{children:["This method is called before the page manager start taking any action. It receives 3 arguments ",(0,t.jsx)(n.code,{children:"managedPage"}),", ",(0,t.jsx)(n.code,{children:"nextManagedPage"})," and ",(0,t.jsx)(n.code,{children:"action"}),". ",(0,t.jsx)(n.code,{children:"managedPage"})," holds information about current page, ",(0,t.jsx)(n.code,{children:"nextManagedPage"}),' about following page. Each of the "managed page" arguments has following shape:']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"{\n  controller: ?(string|function(new: Controller)), // controller class\n  controllerInstance: ?Controller, // instantiated controller\n  decoratedController: ?Controller, // controller decorator created from controller instance\n  view: ?React.Component, // view class/component\n  viewInstance: ?React.Element, // instantiated view\n  route: ?Route, // matched route that leads to the controller\n  options: ?RouteOptions, // route options\n  params: ?Object<string, string>, // route parameters and their values\n  state: {\n    activated: boolean // if the page has been activated\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and finally the ",(0,t.jsx)(n.code,{children:"action"})," is an object describing what triggered the routing. If a ",(0,t.jsx)(n.code,{children:"PopStateEvent"})," triggered the routing the action object will look like this: ",(0,t.jsx)(n.code,{children:"{ type: 'popstate', event: PopStateEvent }"})," otherwise the ",(0,t.jsx)(n.code,{children:"event"})," property will contain ",(0,t.jsx)(n.code,{children:"MouseEvent"})," (e.g. clicked on a link) and ",(0,t.jsx)(n.code,{children:"type"})," property will have value ",(0,t.jsx)(n.code,{children:"'redirect'"}),", ",(0,t.jsx)(n.code,{children:"'click'"})," or ",(0,t.jsx)(n.code,{children:"'error'"}),"."]}),"\n",(0,t.jsxs)(n.h4,{id:"3-handlepostmanagedstate-method",children:["3. ",(0,t.jsx)(n.code,{children:"handlePostManagedState()"})," method"]}),"\n",(0,t.jsxs)(n.p,{children:["This method is a counterpart to ",(0,t.jsx)(n.code,{children:"handlePreManagedState()"})," method. It's called after page transition is finished. It receives similar arguments (",(0,t.jsx)(n.code,{children:"managedPage"}),", ",(0,t.jsx)(n.code,{children:"previousManagedPage"})," and ",(0,t.jsx)(n.code,{children:"action"}),"). ",(0,t.jsx)(n.code,{children:"previousManagedPage"})," holds information about previous page."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," ",(0,t.jsx)(n.code,{children:"handlePreManagedState()"})," and ",(0,t.jsx)(n.code,{children:"handlePostManagedState()"})," methods can interrupt transition process by throwing an error. The thrown error should be instance of ",(0,t.jsx)(n.a,{href:"./error-handling",children:(0,t.jsx)(n.code,{children:"GenericError"})})," with a status code specified. That way the router can handle thrown error accordingly."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"4-destroy-method",children:["4. ",(0,t.jsx)(n.code,{children:"destroy()"})," method"]}),"\n",(0,t.jsx)(n.p,{children:"For purpose of destructing"}),"\n",(0,t.jsx)(n.h2,{id:"registering-pagemanagerhandlers",children:"Registering PageManagerHandlers"}),"\n",(0,t.jsxs)(n.p,{children:["PageManagerHandlers have their own registry ",(0,t.jsx)(n.strong,{children:"PageHandlerRegistry"}),". Every handler you create should be registered as a dependency of this registry."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/config/bind.js\nimport { PageHandlerRegistry, Window } from '@ima/core';\nimport MyOwnHandler from 'app/handler/MyOwnHandler';\n\nexport let init = (ns, oc, config) => {\n  // ...\n\n  if (oc.get(Window).isClient()) { // register different handlers for client and server\n    oc.inject(PageHandlerRegistry, [MyOwnHandler]);\n  } else {\n    oc.inject(PageHandlerRegistry, []);\n  }\n};\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"}),"\xa0Handlers are executed in series and each one waits for the previous one to complete its task."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pagenavigationhandler",children:"PageNavigationHandler"}),"\n",(0,t.jsxs)(n.p,{children:["With introduction of PageManagerHandlers in ",(0,t.jsx)(n.a,{href:"/migration/migration-0.16.0",children:"v16"})," we've moved some functionality to predefined handler ",(0,t.jsx)(n.a,{href:"https://github.com/seznam/ima/blob/master/packages/core/src/page/handler/PageNavigationHandler.js",children:(0,t.jsx)(n.strong,{children:"PageNavigationHandler"})}),". This handler takes care of saving scroll position, restoring scroll position and settings browser's address bar URL. You're free to extend it, override it or whatever else you want."]}),"\n",(0,t.jsx)(n.p,{children:"PageNavigationHandler is registered by default, but when you register your own handlers you need to specify PageNavigationHandler as well."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { PageHandlerRegistry, PageNavigationHandler } from '@ima/core';\nimport MyOwnHandler from 'app/handler/MyOwnHandler';\n\nexport let init = (ns, oc, config) => {\n  // ...\n  oc.inject(PageHandlerRegistry, [PageNavigationHandler, MyOwnHandler]);\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},7346:(e,n,r)=>{r.d(n,{A:()=>a});const a=r.p+"assets/images/diagram-page-manager-e1a61acbae5ac5651fe727dd2c2a8c31.png"},3023:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var a=r(3696);const t={},i=a.createContext(t);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);