"use strict";(self.webpackChunk_ima_docs=self.webpackChunk_ima_docs||[]).push([[9754],{6610:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"basic-features/routing/middlewares","title":"Middlewares","description":"Basic features > Routing > Middlewares","source":"@site/../docs/basic-features/routing/middlewares.md","sourceDirName":"basic-features/routing","slug":"/basic-features/routing/middlewares","permalink":"/basic-features/routing/middlewares","draft":false,"unlisted":false,"editUrl":"https://github.com/seznam/ima/tree/master/docs/../docs/basic-features/routing/middlewares.md","tags":[],"version":"current","lastUpdatedBy":"Jan \u0160ime\u010dek","lastUpdatedAt":1761308686000,"frontMatter":{"title":"Middlewares","description":"Basic features > Routing > Middlewares"},"sidebar":"docs","previous":{"title":"Dynamic Routes","permalink":"/basic-features/routing/dynamic-routes"},"next":{"title":"Async Routing","permalink":"/basic-features/routing/async-routing"}}');var r=t(2540),s=t(3023);const i={title:"Middlewares",description:"Basic features > Routing > Middlewares"},a=void 0,c={},l=[{value:"Function arguments",id:"function-arguments",level:2},{value:"params",id:"params",level:3},{value:"locals",id:"locals",level:3},{value:"route",id:"route",level:4},{value:"action",id:"action",level:4},{value:"next",id:"next",level:3},{value:"Execution order",id:"execution-order",level:2},{value:"Execution timeout",id:"execution-timeout",level:2}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Middlewares are simple functions that run before/after route handlers. They can be used to restrict access to certain set of routes or act based on parsed route params."}),"\n",(0,r.jsxs)(n.p,{children:["There are two types of middleware ",(0,r.jsx)(n.strong,{children:"global"})," and ",(0,r.jsx)(n.strong,{children:"local"}),". As the names suggest the first one is defined globally on the router instance using ",(0,r.jsx)(n.code,{children:"use()"})," method and the second type is bound to specific route and is defined in the route ",(0,r.jsx)(n.code,{children:"options.middlewares"})," property."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",metastring:"title=./app/config/routes.js",children:"// The imports are stripped for compactness.\nexport let init = (ns, oc, config) => {\n  const router = oc.get('$Router');\n\n  router\n    .use(async (params, locals) => {\n      console.log('Global middleware', params, locals, locals.route, locals.action);\n      locals.counter = 0;\n    });\n    .add('home', '/', HomeController, HomeView, {\n      middlewares: [\n        async (params, locals, next) => {\n          next({ counter: counter++ });\n        }\n      ]\n    })\n    .add(RouteNames.ERROR, '/error', ErrorController, ErrorView)\n    .add(RouteNames.NOT_FOUND, '/not-found', NotFoundController, NotFoundView);\n}\n"})}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["Since you have access to the object container (",(0,r.jsx)(n.code,{children:"oc"}),"), you can basically do anything you want in the middlewares."]}),(0,r.jsx)(n.p,{children:"You can easily define authentication middlewares or access-restricting middlewares since throwing an error from the middleware is handled the same way as any other error in the application."})]}),"\n",(0,r.jsx)(n.h2,{id:"function-arguments",children:"Function arguments"}),"\n",(0,r.jsxs)(n.p,{children:["Each middleware can be ",(0,r.jsx)(n.strong,{children:"async"})," and the functions can use up to three arguments: ",(0,r.jsx)(n.code,{children:"params"}),", ",(0,r.jsx)(n.code,{children:"locals"})," and ",(0,r.jsx)(n.code,{children:"next"}),". ",(0,r.jsx)(n.code,{children:"params"})," specifically allows you to modify route params, ",(0,r.jsx)(n.code,{children:"locals"})," is used to pass data between middlewares and ",(0,r.jsx)(n.code,{children:"next"})," callback provides additional"]}),"\n",(0,r.jsx)(n.h3,{id:"params",children:"params"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"object = {}"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Contains route params extracted by the ",(0,r.jsx)(n.strong,{children:"currently matched route handler"}),". Can be empty if there was no route match before execution of concrete middleware."]}),"\n",(0,r.jsx)(n.h3,{id:"locals",children:"locals"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"RouteLocals = {}"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Mutable object you can use to pass data between middlewares. It is passed across all middlewares, so anything you define here, is available in following middleware functions."}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["In addition to mutating the original object, you can also ",(0,r.jsx)(n.strong,{children:"return object values from middlewares"})," or pass them as an argument in the ",(0,r.jsx)(n.code,{children:"next()"})," function. These are then merged into the ",(0,r.jsx)(n.code,{children:"locals"})," upon it's execution."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async (params, locals) => {\n  locals.counter++;\n}\n\n// or\n\nasync (params, locals) => {\n  return { counter: counter++ };\n}\n\n// or\n\nasync (params, locals, next) => {\n  next({ counter: counter++ });\n}\n"})})]}),"\n",(0,r.jsx)(n.p,{children:"Additionally it always contains following keys:"}),"\n",(0,r.jsx)(n.h4,{id:"route",children:"route"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"AbstractRoute"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Instance of currently matched route."}),"\n",(0,r.jsx)(n.h4,{id:"action",children:"action"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"RouteAction = {}"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"An action object describing what triggered this routing (can be empty)."}),"\n",(0,r.jsx)(n.h3,{id:"next",children:"next"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"(result?: object) => void"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When called, this function (as the name suggest) allows you to continue with execution of other route handlers. Apart from other frameworks that use similar feature, when you define ",(0,r.jsx)(n.code,{children:"next"})," argument in your middleware, ",(0,r.jsx)(n.strong,{children:"you have to execute it in order to continue"}),". Otherwise the router will not proceed any further even if the middleware function content finished it's execution."]}),"\n",(0,r.jsx)(n.p,{children:"This is intentional as it allows you to have more control over the middleware execution and gives you ability to stop the routing process completely."}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsxs)(n.p,{children:["This is can be usefull in situations when for example you want to do a redirect, which is synchronous but takes a while until the window is reloaded. Without stopping the middleware execution (by defining the ",(0,r.jsx)(n.code,{children:"next"})," callback and not calling it), you could get a glimpse of Error Page that is rendered before the redirect takes places, because the router continued it's processing."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async (params, locals, next) => {\n  if (await oc.get('User').isLoggedIn()) {\n    // Continue normally\n    return next();\n  }\n\n  // Stop execution by not calling `next()` and do a redirect\n  oc.get('$Router').redirect('/');\n}\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"execution-order",children:"Execution order"}),"\n",(0,r.jsxs)(n.p,{children:["Middleware functions are resolved ",(0,r.jsx)(n.strong,{children:"from top to bottom sequentially"}),". In case of the code above, when routing to ",(0,r.jsx)(n.code,{children:"home"})," route, following things would have happened:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Global middlewares"})," defined above currently matched route are executed (in this case we have only one global middleware, defined above all routes)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Params extraction"})," from currently matched route handler (home) is executed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Local route"})," middlewares are executed (with newly extracted route params)."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In case of an ",(0,r.jsx)(n.strong,{children:"error"})," or not ",(0,r.jsx)(n.strong,{children:"found page"}),", the execution order is still ",(0,r.jsx)(n.strong,{children:"the same"}),", meaning the global and route middlewares are executed as with any other route."]}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsxs)(n.p,{children:["There's only one exception, since the ",(0,r.jsx)(n.code,{children:"locals"})," object is cleared to an empty object before route handling, if an error occurs during route handling and execution is internally passed to error handling (displaying error page), the locals object may retain values that were there for the previous route matching. However the ",(0,r.jsx)(n.code,{children:"locals.route"})," object will still be up to date and equal to currently routed route (error in this case)."]})}),"\n",(0,r.jsx)(n.h2,{id:"execution-timeout",children:"Execution timeout"}),"\n",(0,r.jsx)(n.p,{children:"To prevent middlewares from freezing the application, for example when the middlewares takes too long to execute, we've implemented execution timeout, which prevents them from running indefinitely."}),"\n",(0,r.jsxs)(n.p,{children:["You can ",(0,r.jsx)(n.strong,{children:"customize the timeout value"})," in app settings:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",metastring:'title="./app/config/settings.js"',children:"export default (ns, oc, config) => {\n  return {\n    prod: {\n      $Router: {\n        middlewareTimeout: 30000, // ms\n      },\n    },\n  };\n};\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},3023:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(3696);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);