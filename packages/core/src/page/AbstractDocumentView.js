import AbstractPureComponent from './AbstractPureComponent';

const PRIVATE = {
  masterElementId: Symbol('masterElementId'),
};

if (typeof $Debug !== 'undefined' && $Debug) {
  Object.freeze(PRIVATE);
}

// @server-side class AbstractDocumentView extends __VARIABLE__ {__CLEAR__}\nexports.default = AbstractDocumentView;

/**
 * The base class for document view components. The document view components
 * create the basic markup, i.e. the {@code html} or {@code head} elements,
 * along with an element that will contain the view associated with the current
 * route.
 *
 * Note that the document views are always rendered only at the server-side and
 * cannot be switched at the client-side. Because of this, the document view
 * component must be pure and cannot contain a state.
 *
 * @abstract
 */
export default class AbstractDocumentView extends AbstractPureComponent {
  //#if _SERVER
  /**
   * Returns the ID of the element (the value of the {@code id} attribute)
   * generated by this component that will contain the rendered page view.
   *
   * @abstract
   * @return {string} The ID of the element generated by this component that
   *         will contain the rendered page view.
   */
  static get masterElementId() {
    if (this[PRIVATE.masterElementId] !== undefined) {
      return this[PRIVATE.masterElementId];
    }

    throw new Error(
      'The masterElementId getter is abstract and must be overridden'
    );
  }

  /**
   * Setter for the ID of the element (the value of the {@code id} attribute)
   * generated by this component that will contain the rendered page view.
   *
   * This setter is used only for compatibility with the public class fields
   * and can only be used once per component.
   *
   * @param {string} masterElementId The ID of the element generated by this
   *        component that will contain the rendered page view.
   */
  static set masterElementId(masterElementId) {
    if ($Debug) {
      if (this[PRIVATE.masterElementId] !== undefined) {
        throw new Error(
          'The masterElementId can be set only once and cannot be ' +
            'reconfigured'
        );
      }
    }

    this[PRIVATE.masterElementId] = masterElementId;
  }

  /**
   * Returns array of JS expressions wrapped in string,
   * that are evaluated on frontend and are used to determine if
   * the es version of the FE scripts should be loaded. Each expression
   * should start with return keyword and when all expressions in the array
   * evaluate to true, the es scripts are loaded, otherwise it falls back to
   * the legacy versions of script files.
   *
   * @returns {array[string]} Array of string JS expressions.
   */
  static get esTestScripts() {
    return [
      'return (() => { const o = { t: { q: true } }; return o?.t?.q && (o?.a?.q ?? true); })()',
      'return typeof Promise.allSettled === "function"',
      'return typeof globalThis !== "undefined"',
      'return typeof 9007199254740991n === "bigint"',
    ];
  }

  /**
   * Initializes $IMA.Runner with es or non-es versions of script
   * source files, based on the result of evaluation of the
   * {@code esTestScripts} getter expressions.
   *
   * @returns {string} Inline script used to initialized $IMA.Runner.
   */
  getScripts({ scripts, runtime, esScripts, esRuntime }) {
    return `<script>
      (function() {
        function test(snippet) {
          try {
            var fn = new Function(snippet);
            var result = fn();

            return !!result;
          } catch (e) {
            return false;
          }
        }

        window.$IMA.Runner = window.$IMA.Runner || {};
        var isEsVersion = ${this.constructor.esTestScripts
          .map(script => `test('${script}')`)
          .join(' && ')};

        if (isEsVersion) {
          window.$IMA.Runner.runtime = '${esRuntime}';
          window.$IMA.Runner.scripts = JSON.parse('${JSON.stringify(
            esScripts
          )}');
        } else {
          window.$IMA.Runner.runtime = '${runtime}';
          window.$IMA.Runner.scripts = JSON.parse('${JSON.stringify(scripts)}');
        }

        // Create script callback
        var _createScriptCallback = ${this.createScriptCallback()};

        window.$IMA.Runner.scripts.forEach(_createScriptCallback);
        window.$IMA.Runner.run = function() {
          _createScriptCallback(window.$IMA.Runner.runtime);
        };
      })();
    </script>`;
  }

  /**
   * Callback function injected into the DOM (should be es5 compatible),
   * which is called on every script source. By default it creates a tag
   * that is injected into the DOM.
   *
   * @returns {string} Inlined script function that takes one argument,
   *   which represents the script definitions passed to the {@code getScripts}.
   */
  createScriptCallback() {
    return `function createScript(source) {
      var scriptEl = document.createElement('script');

      if (typeof source === 'string') {
        scriptEl.src = source;
      } else {
        var src = source[0];
        var options = source[1];

        scriptEl.src = src;

        Object.keys(options).forEach(function (attr) {
          if (attr === 'fallback' && options.fallback) {
            scriptEl.onerror = function() {
              var optionsCopy = {};

              // Create options copy and skip fallback
              Object.keys(options).forEach(function (attr) {
                if (attr !== 'fallback') {
                  optionsCopy[attr] = options[attr];
                }
              });

              createScript([options.fallback, optionsCopy]);
            };
          } else {
            scriptEl.setAttribute(attr, options[attr]);
          }
        });
      }

      scriptEl.onload = function () {
        $IMA.Runner.load(source);
      };

      document.getElementById('scripts').appendChild(scriptEl);
    }`;
  }
  //#endif
}
