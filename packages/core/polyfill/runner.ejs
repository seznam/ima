((root) => {
  /**
   * $IMA.Runner can be completely overridden, so we have to shallow merge
   * potential existing object with the default runner.
   */
  root.$IMA = root.$IMA || {};
  root.$IMA.Runner = Object.assign(
    {
      isEsVersion: false,
      source: JSON.parse('#{$Source}'),
      scripts: [],
      loadedScripts: [],
      testSource: {
        scripts: [
          // es9 env test scripts
          'return (() => { const o = { t: 1 }; return { ...o }; })() && (async () => ({}))() && !!Object.values',
        ],
        esScripts: [
          // es13 env test scripts
          'return [1,1].findLast(e => e === 1)',
          'return Object.hasOwn({a:1}, "a")',
        ]
      },

      /**
       * Handles creation of script elements and their injection to the DOM.
       * It also takes care of testing the browser environment and determining
       * what version should be loaded.
       */
      initScripts: () => {
        var runner = root.$IMA.Runner;
        var scriptsRoot = root.document.getElementById('scripts');

        if (!scriptsRoot) {
          scriptsRoot = root.document.createElement('div');
          scriptsRoot.id = 'scripts';
          root.document.body.appendChild(scriptsRoot);
        }

        function testScript(snippet) {
          try {
            var fn = new Function(snippet);
            var result = fn();

            return !!result;
          } catch (e) {
            return false;
          }
        }

        /**
         * Handles script element creation and its insertion
         * to the dom (div#script element). Works with simple string
         * as src or ['src', { options }] format.
         */
        function createScript(source) {
          var scriptEl = root.document.createElement('script');

          if (typeof source === 'string') {
            scriptEl.src = source;
          } else {
            var src = source[0];
            var options = source[1];

            scriptEl.src = src;

            Object.keys(options).forEach((attr) => {
              if (attr === 'fallback' && options.fallback) {
                scriptEl.onerror = () => {
                  var optionsCopy = {};

                  // Create options copy and skip fallback
                  Object.keys(options).forEach((attr) => {
                    if (attr !== 'fallback') {
                      optionsCopy[attr] = options[attr];
                    }
                  });

                  createScript([options.fallback, optionsCopy]);
                };
              } else {
                scriptEl.setAttribute(attr, options[attr]);
              }
            });

            scriptEl.onload = () => {
              runner.onLoad(source);
            };
          }

          scriptsRoot.appendChild(scriptEl);
        }

        /**
         * Sets concrete scripts to the runner based on the currently
         * supported ecma script version. Fallback to legacy scripts if
         * there are no sources for the newer versions.
         */
        if (
          runner.source.esScripts &&
          runner.testSource.esScripts.every(testScript)
        ) {
          runner.isEsVersion = true;
          runner.scripts = runner.source.esScripts;
        } else if (runner.testSource.scripts.every(testScript)) {
          runner.scripts = runner.source.scripts;
        } else {
          return runner.onUnsupported();
        }

        // Create script tags
        if (Array.isArray(runner.scripts)) {
          runner.scripts.forEach(createScript);
        }
      },

      /**
       * Executes the appropriate runtime based on the current
       * es environment after all scripts are loaded. The {esRuntime} and
       * {runtime} placeholders are replaced with the actual runtime code
       * at the build time.
       */
      run: () => {
        var runner = root.$IMA.Runner;

        try {
          /**
           * Run es version of the runtime, in case there are any es scripts sources.
           * Otherwise fallback to the legacy version of the runner.
           */
          if (runner.isEsVersion) {
            /**
             * We need to wrap esRuntime code in a string and execute the function
             * since the code can contain some legacy incompatible syntax, which would
             * break the legacy JS interpreters.
             */
            new Function('<%- esRuntime %>')();
          } else {
            <%- runtime %>
          }
        } catch (error) {
          runner.onError(error);
        }
      },

      /**
       * This handler should be called for every script defined
       * in the scripts array, since only when all of the scripts are
       * loaded, the run callback is called.
       */
      onLoad: (script) => {
        var runner = root.$IMA.Runner;

        runner.loadedScripts.push(
          typeof script === 'string' ? script : script[0]
        );

        if (runner.scripts.length === runner.loadedScripts.length) {
          runner.run();
        }
      },

      /**
       * Optional onError handler. It is triggered in case the runtime
       * code fails to run the application.
       */
      onError: (error) => {
        console.error('IMA Runner ERROR:', error);

        // Show compile errors in error-overlay in $Debug
        if (window.__IMA_HMR && window.$Debug) {
          window.__IMA_HMR.emit('error', { error: error });
        }
      },

      /**
       * Optional onUnsupported handler. It is triggered in case tests
       * for es and legacy version fails, which means that the APP runtime
       * code is never executed.
       */
      onUnsupported: () => {
        console.warn('Unsupported environment, the app runtime was not executed.');
      },
    },
    root.$IMA.Runner || {}
  );

  root.$IMA.Runner.initScripts();
  Object.seal(root.$IMA.Runner);
})(typeof window !== 'undefined' && window !== null ? window : global);
